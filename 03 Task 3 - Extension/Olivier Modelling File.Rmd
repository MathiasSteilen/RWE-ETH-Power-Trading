---
title: "Statslab Modelling Olivier"
author: "Olivier Zehnder"
date: "2024-05-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Loading libraries / Defining functions
```{r}
### Modelling of Swiss Day ahead prices

# Load necessary libraries

library(rugarch)
library(forecast)
library(dplyr)

#Functions
# Define a function to calculate R-squared
calculate_r_squared <- function(true_values, fitted_values) {
  # Calculate the mean of true values
  true_mean <- mean(true_values)
  
  # Calculate total sum of squares (TSS)
  TSS <- sum((true_values - true_mean)^2)
  
  # Calculate residual sum of squares (RSS)
  RSS <- sum((true_values - fitted_values)^2)
  
  # Calculate R-squared
  R_squared <- 1 - (RSS / TSS)
  
  return(R_squared)
}
# Load your dataset

```

Loading data:
```{r}
df <- read.csv("~/Downloads/RWE-ETH-Power-Trading-main-5/00 Data Retrieval and Cleaning/0_df_final_imputed.csv")
df$date <- as.Date(df$date)



```

Cleaning data: Identifying columns which need smoothing
```{r}
colnames(df)

column_names <- colnames(df)
substrings = c("_ch_de","_de_ch","_missing_dummy","_lu","_FR_CH","_ch", "_it", "_at", "_de", "_fr", "_FR", "_CH")
colnames_general= column_names %>% map(~str_remove_all(.,paste(substrings, collapse='|'))) %>% unlist() %>% unique()
library(tidyverse)
write.csv(colnames_general, file = "column_names_correct.csv", row.names = FALSE)

pos=which(df_2023$hydro_reservoir_storage_ch==0)
pos_value=c(pos[1]-1, pos[length(pos)]+1)
df_2023$hydro_reservoir_storage_ch[pos]=mean(df_2023$hydro_reservoir_storage_ch[pos_value])

# Smooth the data using ksmooth
smoothed_data <- ksmooth(x = 1:length(df_2023$hydro_reservoir_storage_ch), y = df_2023$hydro_reservoir_storage_ch, "normal", bandwidth = 7*24)
# Plot the smoothed data
plot(smoothed_data$x, smoothed_data$y, type = "l", main = "Smoothed Hydro Reservoir Storage Changes")


# Function to identify columns with at least 3 consecutive non-zero values
identify_consecutive_values <- function(df) {
  consecutive_cols <- c()  # Initialize vector to store column names
  
  # Loop through each column
  for (col in names(df)) {
    consecutive_count <- 0  # Initialize consecutive count
    
    # Loop through each value in the column
    for (i in 1:(length(df[[col]]) - 2)) {
      # Check if the current and next two values are non-zero and equal
      if (df[[col]][i] != 0 & df[[col]][i] == df[[col]][i + 1] & df[[col]][i] == df[[col]][i + 2]) {
        consecutive_count <- consecutive_count + 1  # Increment consecutive count
        if (consecutive_count >= 20) {
          consecutive_cols <- c(consecutive_cols, col)  # Add column name to vector
          break  # Break the loop if condition met
        }
      } else {
        consecutive_count <- 0  # Reset consecutive count if condition not met
      }
    }
  }
  
  return(consecutive_cols)  # Return vector of column names
}

# Call the function with your dataframe
consecutive_cols <- identify_consecutive_values(df_2023)

# Print the column names with at least 3 consecutive non-zero values
#print(consecutive_cols)

df_repeating=df_2023[,consecutive_cols]

#consecutive_cols


```

Smoothing columns where appropriate (due to measurments not done in an hourly interval)
```{r}
#After checking manually which columns actually must be smoothed, we saw that 
#only the 4 different hydro reservoir storage variables have to be smoothed

df$hydro_reservoir_storage_ch <- ksmooth(x = 1:length(df$hydro_reservoir_storage_ch), y = df$hydro_reservoir_storage_ch, "normal", bandwidth = 7*24)$y
df$hydro_reservoir_storage_at <- ksmooth(x = 1:length(df$hydro_reservoir_storage_at), y = df$hydro_reservoir_storage_at, "normal", bandwidth = 7*24)$y
df$hydro_reservoir_storage_fr <- ksmooth(x = 1:length(df$hydro_reservoir_storage_fr), y = df$hydro_reservoir_storage_fr, "normal", bandwidth = 7*24)$y
df$hydro_reservoir_storage_it <- ksmooth(x = 1:length(df$hydro_reservoir_storage_it), y = df$hydro_reservoir_storage_it, "normal", bandwidth = 7*24)$y

write.csv(df, file = "df_imputed_dummy_smoothed", row.names = FALSE)



plot(df$hydro_reservoir_storage_ch[0:10000], type="l")
```

Initilizing data set of 2023 for shorter training
```{r}
sorted_df <- arrange(df, date)


df_2023= sorted_df[35010:44510,]

```



##Part One##: Baseline Model

As a baseline, we fit a linear regression to see how well it will perform

```{r}
### PART ONE: BASELINE MODEL - Linear Regression 
fit_DA_CH= lm(day_ahead_price_ch~., data=df)
fit_DA_DE= lm(day_ahead_price_de~., data=df)
fit_AC_CH_DE= lm(auction_price_ch_de~., data=df)
fit_AC_DE_CH= lm(auction_price_de_ch~., data=df)


#Visualization of fit:
plot(df$day_ahead_price_ch[0:1000], type="l", main="fit_DA_CH")
lines(fit_DA_CH$fitted.values[0:1000], col="red")

plot(df$day_ahead_price_de[0:1000], type="l", main="fit_DA_DE")
lines(fit_DA_DE$fitted.values[0:1000], col="red")

plot(df$auction_price_ch_de[0:1000], type="l", main="fit_AC_CH_DE")
lines(fit_AC_CH_DE$fitted.values[0:1000], col="red")

plot(df$auction_price_de_ch[0:1000], type="l", main="fit_AC_DE_CH")
lines(fit_AC_DE_CH$fitted.values[0:1000], col="red")


```

First Findings:
While a simple model like a multiple linear regression seems to do fairly well:
at fitting:
- Swiss Day Ahead Prices
- German Day Ahead Prices
- Auction prices from Germany to Switzerland


However, it seems not to be able to fit at all the: 
- Auction prices from Switzerland to Germany


Following, we will evaluate the performance of the linear model with the R2 and 
the mse metrics. While we are aware of the drawbacks of these method, we consider
them useful to get a first insight into how well a model fits the data


```{r}
#First Insights: Every fit seems to be decent, except for the Auction price from 
print("Swiss DA Prices:")
(R2= calculate_r_squared(df$day_ahead_price_ch, fit_DA_CH$fitted.values))
(mse= mean((df$day_ahead_price_ch -fit_DA_CH$fitted.values)^2))

print("German DA Prices:")
(R2= calculate_r_squared(df$day_ahead_price_de, fit_DA_DE$fitted.values))
(mse= mean((df$day_ahead_price_de -fit_DA_DE$fitted.values)^2))

print("Auction Prices: CH-DE")
(R2= calculate_r_squared(df$auction_price_ch_de, fit_AC_CH_DE$fitted.values))
(mse= mean((df$auction_price_ch_de -fit_AC_CH_DE$fitted.values)^2))

print("Auction Prices: DE-CH")
(R2= calculate_r_squared(df$auction_price_de_ch, fit_AC_DE_CH$fitted.values))
(mse= mean((df$auction_price_de_ch -fit_AC_DE_CH$fitted.values)^2))
```



##Part Two ##: Mixed Model

In the next approach, we are going to take the residuals from our first fit and
see if we can run a GARCH model on them. Our final prediction in this approach 
will be the sum of the prediction of the linear model and the prediction of the 
residual from the GARCH model


First we need to calculate the residuals: 
```{r}

# Calculate residuals

residuals_DA_CH= df$day_ahead_price_ch - fit_DA_CH$fitted.values
residuals_DA_DE=df$day_ahead_price_de - fit_DA_DE$fitted.values
residuals_AC_CH_DE=df$auction_price_ch_de  - fit_AC_CH_DE$fitted.values
residuals_AC_DE_CH=df$auction_price_de_ch - fit_AC_DE_CH$fitted.values


  
```



Now we will run a GARCH model on the residuals for each different response 
variable

1. SWISS DAY AHEAD PRICES
```{r}
#making data stationary
residuals=residuals_DA_CH

q_value=c(0,1,2,3,4,5)
p_values=c(0,1,2,3,4,5)
results_mat= matrix(NA,length(q_value), length(p_values))
for (q in q_value){
  for (p in p_values){
    stationary_data <- log(residuals+500)
    
    
    garch_model <- ugarchspec(mean.model = list(armaOrder = c(q, p)), 
                              variance.model = list(model = "sGARCH"), 
                              distribution.model = "norm")
    fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
    fitted_values= fitted(fit_garch)
    length(fitted_values)
    
    mse=mean((stationary_data -fitted_values)^2)
    
    cat("with q = ", q, " and p = ", p, " --> MSE: ", mse, "\n")
    results_mat[q+1,p+1]= mse
    
  }
}

min(results_mat)
min_index <- which(results_mat == min(results_mat), arr.ind = TRUE)
min_index


```
As we see, the best parameters for the models are q=4 and p=4

```{r}

garch_model <- ugarchspec(mean.model = list(armaOrder = c(4, 4)), 
                          variance.model = list(model = "sGARCH"), 
                          distribution.model = "norm")
fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
stationary_predictions= fitted(fit_garch)


original_predictions=exp(stationary_predictions)-500

plot(original_predictions, type="l")

fit_garch_DA_CH= fit_garch
predictions_garch_DA_CH= original_predictions

```

In a next step we are going to see if we were able to increase the performance 
of the linear model if we combine it with the GARCH model:

```{r}

#Checking if GARCH improved model performance
fit= fit_DA_CH
garch_predictions= predictions_garch_DA_CH
actual_y_values= df$day_ahead_price_ch



Mixed_Model_predicitons=fit$fitted.values+garch_predictions

R2_lin= calculate_r_squared(actual_y_values, fit$fitted.values)
R2_mixed= calculate_r_squared(actual_y_values, Mixed_Model_predicitons)
print("Including GARCH changed the R2 by:")
print(R2_mixed-R2_lin)

mse_lin= mean((actual_y_values -fit$fitted.values)^2)
mse_mixed= mean((actual_y_values -Mixed_Model_predicitons)^2)
print("Including GARCH changed the MSE by:")
print(mse_mixed-mse_lin)
```
As the R2 metric has improved slightly, and the MSE has 
decreased quite a lot, we can conclude that the mixed model is significantly 
better at modelling the Swiss Day ahead prices

2. GERMAN DAY AHEAD PRICES
```{r}
#making data stationary
residuals=residuals_DA_DE

q_value=c(0) #Model often failed to converge if q was not eaual to 0
p_values=c(0,1,2,3,4,5)
results_mat= matrix(NA,length(q_value), length(p_values))
for (q in q_value){
  for (p in p_values){
    if (q!=1 | p!=1){
      
      stationary_data <- log(residuals+500)
      
      
      garch_model <- ugarchspec(mean.model = list(armaOrder = c(q, p)), 
                                variance.model = list(model = "sGARCH"), 
                                distribution.model = "norm")
      fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
      fitted_values= fitted(fit_garch)
      length(fitted_values)
      
      mse=mean((stationary_data -fitted_values)^2)
      
      cat("with q = ", q, " and p = ", p, " --> MSE: ", mse, "\n")
      results_mat[q+1,p+1]= mse
    }
  }
}

min(results_mat)
min_index <- which(results_mat == min(results_mat), arr.ind = TRUE)
min_index


```


As we see, the best parameters for the models are q=0 and p=5

```{r}

garch_model <- ugarchspec(mean.model = list(armaOrder = c(0, 5)), 
                          variance.model = list(model = "sGARCH"), 
                          distribution.model = "norm")
fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
stationary_predictions= fitted(fit_garch)


original_predictions=exp(stationary_predictions)-500

plot(original_predictions, type="l")

fit_garch_DA_DE= fit_garch
predictions_garch_DA_DE= original_predictions

```

Evaluating the prformance of the mixed model
```{r}


#Checking if GARCH improved model performance
fit= fit_DA_DE
garch_predictions= predictions_garch_DA_DE
actual_y_values= df$day_ahead_price_de



Mixed_Model_predicitons=fit$fitted.values+garch_predictions

R2_lin= calculate_r_squared(actual_y_values, fit$fitted.values)
R2_mixed= calculate_r_squared(actual_y_values, Mixed_Model_predicitons)
print("Including GARCH changed the R2 by:")
print(R2_mixed-R2_lin)

mse_lin= mean((actual_y_values -fit$fitted.values)^2)
mse_mixed= mean((actual_y_values -Mixed_Model_predicitons)^2)
print("Including GARCH changed the MSE by:")
print(mse_mixed-mse_lin)
```
Also for the german day ahead prices the mixed models seems to performe quite a 
bit better


3. AUCTION PRICES CH - DE
```{r}
#making data stationary
residuals=residuals_AC_CH_DE

q_value=c(0,1,2,3,4,5) #Model often failed to converge if q was not eaual to 0
p_values=c(0,1,2,3,4,5)
results_mat= matrix(NA,length(q_value), length(p_values))
for (q in q_value){
  for (p in p_values){
    if (q!=1 | p!=1){
      
      stationary_data <- log(residuals+500)
      
      
      garch_model <- ugarchspec(mean.model = list(armaOrder = c(q, p)), 
                                variance.model = list(model = "sGARCH"), 
                                distribution.model = "norm")
      fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
      fitted_values= fitted(fit_garch)
      length(fitted_values)
      
      mse=mean((stationary_data -fitted_values)^2)
      
      cat("with q = ", q, " and p = ", p, " --> MSE: ", mse, "\n")
      results_mat[q+1,p+1]= mse
    }
  }
}

min(results_mat, na.rm = TRUE)
min_index <- which(results_mat == min(results_mat), arr.ind = TRUE)
min_index


```


As we see, the best parameters for the models are q=1 and p=4

```{r}

garch_model <- ugarchspec(mean.model = list(armaOrder = c(1, 4)), 
                          variance.model = list(model = "sGARCH"), 
                          distribution.model = "norm")
fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
stationary_predictions= fitted(fit_garch)


original_predictions=exp(stationary_predictions)-500

plot(original_predictions, type="l")

fit_garch_AC_CH_DE= fit_garch
predictions_garch_AC_CH_DE= original_predictions

```



```{r}


#Checking if GARCH improved model performance
fit= fit_AC_CH_DE
garch_predictions= predictions_garch_AC_CH_DE
actual_y_values= df$auction_price_ch_de



Mixed_Model_predicitons=fit$fitted.values+garch_predictions

R2_lin= calculate_r_squared(actual_y_values, fit$fitted.values)
R2_mixed= calculate_r_squared(actual_y_values, Mixed_Model_predicitons)
print("Including GARCH changed the R2 by:")
print(R2_mixed-R2_lin)

mse_lin= mean((actual_y_values -fit$fitted.values)^2)
mse_mixed= mean((actual_y_values -Mixed_Model_predicitons)^2)
print("Including GARCH changed the MSE by:")
print(mse_mixed-mse_lin)
```
The model actually performed worse for the auction price modelling (decreasing R2 and increasing the MSE)



4. AUCTION PRICES DE-CH
```{r}
#making data stationary
residuals=residuals_AC_DE_CH

q_value=c(0,1,2,3,4,5) #Model often failed to converge if q was not eaual to 0
p_values=c(0,1,2,3,4,5)
results_mat= matrix(NA,length(q_value), length(p_values))
for (q in q_value){
  for (p in p_values){
    if (q!=1 | p!=1){
      
      stationary_data <- log(residuals+500)
      
      
      garch_model <- ugarchspec(mean.model = list(armaOrder = c(q, p)), 
                                variance.model = list(model = "sGARCH"), 
                                distribution.model = "norm")
      fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
      fitted_values= fitted(fit_garch)
      length(fitted_values)
      
      mse=mean((stationary_data -fitted_values)^2)
      
      cat("with q = ", q, " and p = ", p, " --> MSE: ", mse, "\n")
      results_mat[q+1,p+1]= mse
    }
  }
}

min(results_mat)
min_index <- which(results_mat == min(results_mat), arr.ind = TRUE)
min_index


```

As we see, the best parameters for the models are q=2 and p=1

```{r}

garch_model <- ugarchspec(mean.model = list(armaOrder = c(2, 1)), 
                          variance.model = list(model = "sGARCH"), 
                          distribution.model = "norm")
fit_garch <- ugarchfit(spec = garch_model, data = stationary_data)
stationary_predictions= fitted(fit_garch)


original_predictions=exp(stationary_predictions)-500

plot(original_predictions, type="l")

fit_garch_AC_CH_DE= fit_garch
predictions_garch_AC_DE_CH= original_predictions

```

```{r}

#Checking if GARCH improved model performance
fit= fit_AC_DE_CH
garch_predictions= predictions_garch_AC_DE_CH
actual_y_values= df$auction_price_de_ch



Mixed_Model_predicitons=fit$fitted.values+garch_predictions

R2_lin= calculate_r_squared(actual_y_values, fit$fitted.values)
R2_mixed= calculate_r_squared(actual_y_values, Mixed_Model_predicitons)
print("Including GARCH changed the R2 by:")
print(R2_mixed-R2_lin)

mse_lin= mean((actual_y_values -fit$fitted.values)^2)
mse_mixed= mean((actual_y_values -Mixed_Model_predicitons)^2)
print("Including GARCH changed the MSE by:")
print(mse_mixed-mse_lin)
```
For the german day ahead prices, the mixed model again seems to increase performance quite a lot especially in terms of MSE



#Conclusion Mixed Models#

The mixed model, applying a GARCH model to the residuals of the linear model, seems to perform better than the linar model alone. The only exception is the modelling of the Auction Prices from Switzerland to Germany, however, this model is very badly approximated by either, the linear and the mixed model.


## PART 3: GARCH ONLY###


In the following part, we will use the rugarch package to directly place our 
formula into the GARCH function, in order to see how much this approach deviates
from the mixed model approach we have shown in Part 2  

Making the data stationary: (TRYING STH NEW)


```{r}

## Function to make a series stationary by differencing
make_stationary <- function(series) {
  if (!is.numeric(series)) {
    cat("Non-numeric column:", colnames(data)[which(colnames(data) == colnames(series))], "\n")
    return(NULL)
  }
  diff(series, lag = 1, differences = 1)  # First-order differences
}

#### MAjor Issue: How can we make non-numeric data stationary so that we can feed it into the GARCH model??

# Apply differencing to each column
data_stationary <- lapply(df, make_stationary)

# Remove NULL elements (non-numeric columns)
data_stationary <- data_stationary[!sapply(data_stationary, is.null)]

# Convert the result back to a dataframe
data_stationary <- as.data.frame(data_stationary)


```


Running the models (using the respective arma order from the mixed models)
```{r}

# Define the GARCH model specification
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0)), 
                   variance.model = list(garchOrder = c(1, 1)), 
                   distribution.model = "std")


# Define the formula including the dependent variable and predictor variables
formula_auction_DE_CH <- auction_price_de_ch ~.
formula_auction_CH_DE <- auction_price_ch_de ~.
formula_DA_price_ch <- day_ahead_price_ch ~.
formula_DA_price_de <- day_ahead_price_de ~.

# Fit the GARCH model to the data
fit_DA_price_ch <- ugarchfit(spec, data = data_stationary, formula = formula_DA_price_ch)
fit_DA_price_de <- ugarchfit(spec, data = data_stationary, formula = formula_DA_price_de)
fit_auction_CH_DE <- ugarchfit(spec, data = data_stationary, formula = formula_auction_CH_DE)
fit_auction_DE_CH <- ugarchfit(spec, data = data_stationary, formula = formula_auction_DE_CH)



```


```{r}


###Resiudal Analysis:###

# Plotting the residuals
residuals_auct_DE_CH <- residuals(fit_auction_DE_CH)
residuals_auct_CH_DE <- residuals(fit_auction_CH_DE)
residuals_DA_price_ch<- residuals(fit_DA_price_ch)
residuals_DA_price_de <- residuals(fit_DA_price_de)


# Plot histogram of residuals
hist(residuals_auct_DE_CH, breaks = 20, main = "Histogram of Residuals")
hist(residuals_auct_CH_DE, breaks = 20, main = "Histogram of Residuals")
hist(residuals_DA_price_ch, breaks = 20, main = "Histogram of Residuals")
hist(residuals_DA_price_de, breaks = 20, main = "Histogram of Residuals")

# Plot QQ plot of residuals
qqnorm(residuals_auct_DE_CH)
qqline(residuals_auct_DE_CH)

qqnorm(residuals_auct_CH_DE)
qqline(residuals_auct_CH_DE)

qqnorm(residuals_DA_price_ch)
qqline(residuals_DA_price_ch)

qqnorm(residuals_DA_price_de)
qqline(residuals_DA_price_de)

#### --> Residuals are not normally distributed: ISsue....

###Calculate MSE
# Predictions from the GARCH model
predictions1 <- fitted(fit_auction_DE_CH)
predictions2 <- fitted(fit_auction_CH_DE)
predictions3 <- fitted(fit_DA_price_ch)
predictions4 <- fitted(fit_DA_price_de)


# Actual values of the dependent variable
actual_values1 <- data_stationary$auction_price_de_ch  # Assuming 'y' is your dependent variable in the original data
actual_values2<- data_stationary$auction_price_ch_de # Assuming 'y' is your dependent variable in the original data
actual_values3 <- data_stationary$day_ahead_price_ch  # Assuming 'y' is your dependent variable in the original data
actual_values4 <- data_stationary$day_ahead_price_de  # Assuming 'y' is your dependent variable in the original data

# Calculate Mean Squared Error
mse1 <- mean((actual_values1 - predictions1)^2)
mse2 <- mean((actual_values2 - predictions2)^2)
mse3 <- mean((actual_values3 - predictions3)^2)
mse4 <- mean((actual_values4 - predictions4)^2)

# Print MSE
print(paste("Mean Squared Error (MSE):", mse1))
print(paste("Mean Squared Error (MSE):", mse2))
print(paste("Mean Squared Error (MSE):", mse3))
print(paste("Mean Squared Error (MSE):", mse4))

var(data_stationary$auction_price_ch_de)
var(data_stationary$auction_price_de_ch)
var(data_stationary$day_ahead_price_ch)
var(data_stationary$day_ahead_price_de)




```
As the MSE is basically equal to the variance of the stationarized data, this approach does not seem to really work




Ideas on how to change the approach:

- Not stationarizing the predictor variables but only the response
Issue: using a simple log transformation to stationarize the response variable (adding a constant first to avoid taking the log of a negative number), the model does not converge (i.e. it runs way longr than every other model so far without ever finishing...)

- using different armaOrders and Garch Orders

```{r}
min(df$day_ahead_price_ch)
stationary_DA_CH= log(df$day_ahead_price_ch+150)
df_stationarized= df
df_stationarized$day_ahead_price_ch=log(df$day_ahead_price_ch+150)

```



```{r}
# Define the GARCH model specification
spec <- ugarchspec(mean.model = list(armaOrder = c(0, 0)), 
                   variance.model = list(garchOrder = c(1, 1)), 
                   distribution.model = "std")


# Define the formula including the dependent variable and predictor variables
formula_auction_DE_CH <- auction_price_de_ch ~.
formula_auction_CH_DE <- auction_price_ch_de ~.
formula_DA_price_ch <- day_ahead_price_ch ~.
formula_DA_price_de <- day_ahead_price_de ~.

# Fit the GARCH model to the data
fit_DA_price_ch <- ugarchfit(spec, data = df_stationarized, formula = formula_DA_price_ch)
fit_DA_price_de <- ugarchfit(spec, data = data_stationary, formula = formula_DA_price_de)
fit_auction_CH_DE <- ugarchfit(spec, data = data_stationary, formula = formula_auction_CH_DE)
fit_auction_DE_CH <- ugarchfit(spec, data = data_stationary, formula = formula_auction_DE_CH)




```


```{r}


```


```{r}


```


```{r}


```


```{r}


```


```{r}


```
