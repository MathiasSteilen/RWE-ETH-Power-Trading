---
title: "fastTS"
author: "Federico Deotto"
date: "2024-04-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(ggsci)
library(scales)
library(shiny)
library(ncvreg)



setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Default theme for charts
theme_set(
  theme_bw() +
    theme(  
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(
        face = "italic", size = 10, colour = "green50"
      )
    )
)

```

## The Goal

Adapt the fastTS model for the different time window and for the different scenario.
This operation has to be done for all the four prices.

This file is specific to the german price.


```{r}
df_scenario_a <- read_csv("../00 Data Retrieval and Cleaning/0_df_final_imputed_shifting_a.csv")
```

Convert dummies for missing values and variable dst into factor, and ensure that all numeric colums are encoded as such.

```{r}
df <- df %>% 
  mutate(date = with_tz(date, tzone = "UTC"))

df <- df %>%
  mutate_at(vars(-date), as.numeric)

dummies_columns <- df %>%
  select(contains("_missing_dummy")) %>% 
  colnames()

factor_colums <- c('dst', dummies_columns)

df <- df %>%
  mutate_at(vars(factor_colums), factor)
```

# Cutting of time series 

The timestamps are selected arbitrarily. The guiding idea behind the choice was to roughly recover some stationarity conditions in the log-transformed price.
```{r}
first_cut <- as.POSIXct("2021-06-30 23:00:00", tz = "UTC")
second_cut <- as.POSIXct("2022-12-31 23:00:00", tz = "UTC")
```

Create a data.frame that contains exclusively the box_transformation of the four prices and their timestamp (date).
```{r}
prices_name <- c('day_ahead_price_de', 
                 'day_ahead_price_ch',
                 'auction_price_ch_de',
                 'auction_price_de_ch')
df_box <- df %>% 
  select(c('date', prices_name))

#log_transform <- function(x) {
#  log_shifted <- log(x - min(x) + 1)  # Shift all values to ensure positivity
#  return(log_shifted)
#}

boxcox_transform <- function(x, lambda = 0) {
  y = x - min(x) + 1
  if (lambda == 0) {
    log(y)
  } else {
    (y^lambda - 1) / lambda
  }
}


df_box <- df_box %>%
  mutate_at(vars(all_of(prices_name)), ~ boxcox_transform(., lambda = 0))
```


```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


We can see that the log_transformation is not good with the auction_prices. Try another boxCox transformation in order to take care of skewness. The interpretability of the final modell will be compromise, since the log transformation guarantees an interpretation of the coeficient in terms of percentage change.

```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```

```{r}
auction_price <- prices_name[3:4]
df_box[, auction_price] <- df[, auction_price]

df_box <- df_box %>%
  mutate_at(vars(all_of(auction_price)), ~ boxcox_transform(., lambda = -0.001))
```



```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


# PRICE ELECTRICITY GERMANY

In this section we focus in the analysis of the german elcetricity price.

```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
date_outlier <- df_box %>%
  filter(day_ahead_price_de == min(day_ahead_price_de)) %>% 
  pull(date)
```


```{r}
library(fastTS)
library(xts)
```

```{r}
substrings_to_remove <- c('_ch_de', '_de_ch', '_at', '_fr', '_ch', '_de',
                          '_it', '_missing_dummy', '_FR_CH', '_lu')

variable_names <- df %>% colnames() %>% 
  map(~str_remove_all(., paste(substrings_to_remove, collapse = "|")))  %>%
  unlist() %>% 
  unique()

variable_names

variable_forecast <- variable_names[str_detect(variable_names, 'forecast')] %>%
  str_remove('_forecast')
variable_forecast
```

Is there a way to select variables before training? First, let's consider how the day-ahead price is determined. The price for tomorrow (t+24:48) is established using all available information as of today morning (t). 
So, if not justified by further reasoning, it doesn't make sense to use the actual quantity of electricity from water reservoirs at (t+24) to model the electricity price at (t+24) (prediction context). While there are cases where the electricity production for the next day can be predicted quite accurately, it's not necessarily true for all variables we're considering. Therefore, the preferred approach is to use forecasts, which may not perfectly align with those used by traders during auctions but are the closest approximation.

In instances where forecasts are unavailable, we'll resort to using actual production data at (t+24), which can serve as a proxy for a forecast (assuming our company possesses highly accurate internal predictions). However, this approach is subject to debate (prediction context).

The previous arguments were all based on the assumption of a model that needs to be cautious about potential data leakage, as we aim for a model that precisely replicates how prices are formed and can be deployed within a company. Additionally, there's a more descriptive approach that involves utilizing variables observed at time t+24. The rationale for doing this is to discover possible insights.

We'll adapt three models:

The first model incorporates additional information and is lagged by 24 hours, effectively simulating an internal forecast. In this model, we must avoid using prices from other countries at time t+24 for the JAO prediction, as this would constitute a significant information leak. However, for the Switzerland price, we can use the JAO results; analogously for Germany, Austria, France, and Italy, we can use the prices of Switzerland and JAO. The second model includes only the forecasted variables (solar, wind onshore, capacity).In these two models is also necessary to set the lag as covariates greater than 23.  The third takes into account all variables.



#SHINY TWO TIME SERIES AND SCALED

```{r}
# Define UI for the application
ui <- fluidPage(
  
  # Application title
  titlePanel("Interactive Time Series Plot"),
  
  # Sidebar layout
  sidebarLayout(
    sidebarPanel(
      # Select input for choosing time series
      selectInput("time_series1", "Select Time Series 1:",
                  choices = colnames(select_if(df, is.numeric))),
      selectInput("time_series2", "Select Time Series 2:",
                  choices = colnames(select_if(df, is.numeric))),
      dateRangeInput("date_range", "Select Date Range:",
                     start = min(df$date), end = max(df$date),
                     min = min(df$date), max = max(df$date)),
      radioButtons("plot_type", "Plot Type:",
                   choices = c("Original", "Scaled and Centered"),
                   selected = "Original"),
      tags$style(".sidebar {width: 100px; height: 600px; overflow-y: auto;}")
    ),
    
    # Main panel with plot
    mainPanel(
      plotOutput("time_series_plot", height = "700px", width = "100%")
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  
   session$onSessionEnded(function() {
    stopApp()
  })
  
  # Reactive expression for filtered data based on selected time series and time window
  filtered_data <- reactive({
    df %>%
      filter(date >= input$date_range[1] & date <= input$date_range[2]) %>% 
      select(date, !!input$time_series1, !!input$time_series2)
  })
  
  # Reactive expression for scaled and centered data
  scaled_centered_data <- reactive({
    data <- filtered_data()
    if (input$plot_type == "Scaled and Centered") {
      for (col in c(input$time_series1, input$time_series2)) {
        data[[col]] <- scale(data[[col]], center = TRUE, scale = TRUE)
      }
    }
    return(data)
  })
  
  output$time_series_plot <- renderPlot({
    if (input$plot_type == "Original") {
      ggplot(filtered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Time Series Plot", x = "Date Time", y = "Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    } else {
      ggplot(scaled_centered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Scaled and Centered Time Series Plot", x = "Date Time", y = "Scaled and Centered Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    }
  })
  
}

# Run the application
#shinyApp(ui = ui, server = server)


```



# SPARSE LASSO



In the following chunk we create the matrfix of the covariates based on the criteria explained previously. The matrix for the model with all sync variables is not hear since Idk how to construct it.
```{r}
n <- nrow(df)
lag = 24
variable_forecast <- grep("forecast", names(df), value = TRUE)
df_1 <- df %>% 
  select(c(date, day_ahead_price_de,
           variable_forecast)) %>% 
  slice(1:(n-lag))

#prices other countries
x1 <- df %>% 
  select(c(day_ahead_price_at, day_ahead_price_fr, day_ahead_price_it, 
           auction_price_ch_de, auction_price_de_ch, day_ahead_price_ch,
           allocatedCapacity_ch_de, allocatedCapacity_de_ch, ATC_ch_de, ATC_de_ch, actual_load_at, actual_load_de, actual_load_ch, actual_load_ch_missing_dummy, actual_load_fr_missing_dummy, actual_load_it_missing_dummy, actual_load_it, actual_load_fr, crossborder_actual_flow_at_ch, crossborder_actual_flow_ch_at, crossborder_actual_flow_ch_de_lu, crossborder_actual_flow_ch_fr, crossborder_actual_flow_ch_it, crossborder_actual_flow_de_lu_ch, crossborder_actual_flow_fr_ch, crossborder_actual_flow_it_ch, crossborder_actual_flow_at_ch_missing_dummy, crossborder_actual_flow_ch_at_missing_dummy, crossborder_actual_flow_ch_de_lu_missing_dummy, crossborder_actual_flow_ch_fr_missing_dummy, crossborder_actual_flow_ch_it_missing_dummy, crossborder_actual_flow_de_lu_ch_missing_dummy, crossborder_actual_flow_fr_ch_missing_dummy, crossborder_actual_flow_it_ch_missing_dummy)) %>% 
  slice((lag+1):n)

df_1 <- cbind(df_1, x1)

#name_temp <- colnames(df_1)
#x <- df %>% 
#  select(-name_temp) %>% 
#  slice(1:(n-lag))
#
#df_2 <- cbind(df_1, x)
#
#x <- df %>% 
#  select(-name_temp) %>% 
#  slice((lag+1):n)
#
#df_3 <- cbind(df_1, x)
```

```{r}
x <- df %>% select(date, dst)

x = x |> 
  mutate(
    cal_year = year(date),
    cal_month = month(date),
    cal_day_in_month = day(date),
    cal_day_in_week = wday(date, label = F),
    cal_week_in_year = week(date),
    cal_quarter = quarter(date),
    cal_hour_in_day = hour(date),
)

x <- x %>%
  select(-date)

x <- mutate_all(x, as.factor)


formula_str <- paste(" ~ -1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
                     paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)

x <- model.matrix(formula_str, data = x)

tibble(x)
```


```{r}
x <- x %>% 
  as.data.frame() %>% 
  slice(1:(n-lag))
df_1 <- cbind(df_1, x)  #this model does not contain many variable
```



```{r}
library(fastTS)
library(xts)

df1 <- df_1 # %>% 
  #filter(date < second_cut & date > first_cut)
  

y <- xts(df1$day_ahead_price_de,
       order.by = df1$date)

x <- df1 %>% 
  select(-c(date, day_ahead_price_de))

x <- x %>%
  mutate(across(everything(), as.numeric)) %>% 
  as.matrix()

fit1 <- fastTS(y, x, ptrain = 0.8)
#x1 <- scale(x) %>% as.data.frame() %>%   select_if(~ !any(is.na(.)))
#fit2 <- fastTS(y, scale(x1))

summary(fit1)
#summary(fit2)
```


Don't really got it how the scaling works. From CRAN seems it scale but if I first scale obtain different results.

```{r}
fit1$oos_results
coef(fit1)[coef(fit1) != 0,]   %>% sort(decreasing = T) %>% names()
```

```{r}
#lol <- as.matrix(coef(fit1) %>% sort(decreasing = T))
#
#lol <- coef(fit2)[coef(fit2) != 0,] %>% sort(decreasing = F) %>% names()
#lol[!grepl("lag", lol)]
```

```{r}
lol <- fit1$fits 
lol <- lol[[1]]


fit1$y %>%  dim()
fit1$y_cc_train %>% dim() # fit1$y*fit1$ptrain -fit1$n_lags_max
fit1$Xfulltrain %>% dim() # add #fit1$n_lags_max predictors
fit1$X %>% dim()
fit1$train_idx %>% length()

fit1$X %>% nrow() - fit1$Xfulltrain %>% nrow()


f1 <- fit1$fits[[1]]
pos <- which.min(f1$loss)
pred <- f1$beta[ , pos]
```

```{r}
#has_intercept <- which(grepl("Intercept", names(pred)))
#pred %>% head()  ----> ADD INTERCEPT 


X <- cbind(rep(1, nrow(fit1$Xfulltrain)), fit1$Xfulltrain) #matrix w/ intercept
fitted <- X %*% pred %>% matrix(ncol = 1)
date_index <- index(fit1$y_cc_train)
de <- coredata(fit1$y_cc_train)
sol <- data.frame('de' = de, 
                  'fit' = fitted,
                  'date' = date_index)
sol <- sol %>% 
  mutate(diff = de - fit)
```


```{r}
sol %>% 
  #filter(date > as.POSIXct("2022-08-11 17:00:00", tz = 'UTC')) %>% 
  ggplot(aes(x = date))+
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  geom_line(aes(y = fit, col = 3))+
  geom_line(aes(y = de, col = 2)) +
  theme()
```




```{r}
# Define UI for the application
ui <- fluidPage(
  
  # Application title
  titlePanel("Interactive Time Series Plot"),
  
  # Sidebar layout
  sidebarLayout(
    sidebarPanel(
      # Select input for choosing time series
      selectInput("time_series1", "Select Time Series 1:",
                  choices = colnames(select_if(sol, is.numeric))),
      selectInput("time_series2", "Select Time Series 2:",
                  choices = colnames(select_if(sol, is.numeric))),
      dateRangeInput("date_range", "Select Date Range:",
                     start = min(sol$date), end = max(sol$date),
                     min = min(sol$date), max = max(sol$date)),
      radioButtons("plot_type", "Plot Type:",
                   choices = c("Original", "Scaled and Centered"),
                   selected = "Original"),
      tags$style(".sidebar {width: 100px; height: 600px; overflow-y: auto;}")
    ),
    
    # Main panel with plot
    mainPanel(
      plotOutput("time_series_plot", height = "700px", width = "100%")
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  
  session$onSessionEnded(function() {
    stopApp()
  })
  
  # Reactive expression for filtered data based on selected time series and time window
  filtered_data <- reactive({
    sol %>%
      filter(date >= input$date_range[1] & date <= input$date_range[2]) %>% 
      select(date, !!input$time_series1, !!input$time_series2)
  })
  
  # Reactive expression for scaled and centered data
  scaled_centered_data <- reactive({
    data <- filtered_data()
    if (input$plot_type == "Scaled and Centered") {
      for (col in c(input$time_series1, input$time_series2)) {
        data[[col]] <- scale(data[[col]], center = TRUE, scale = TRUE)
      }
    }
    return(data)
  })
  
  output$time_series_plot <- renderPlot({
    if (input$plot_type == "Original") {
      ggplot(filtered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Time Series Plot", x = "Date Time", y = "Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    } else {
      ggplot(scaled_centered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Scaled and Centered Time Series Plot", x = "Date Time", y = "Scaled and Centered Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    }
  })
  
}

# Run the application
shinyApp(ui = ui, server = server)
```

```{r}
sol %>% 
  #filter(date > as.POSIXct("2022-08-11 17:00:00", tz = 'UTC')) %>% 
  ggplot(aes(x = date))+
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  geom_line(aes(y = diff, col = 3))+
  theme()
```



# Try to make faster procedure


```{r}
model_list <- function(data, p.train = 0.8){
    y <- xts(data$day_ahead_price_de,
       order.by = data$date)

    x <- data %>% 
      select(-c(date, day_ahead_price_de))
  
    x <- x %>%
      mutate(across(everything(), as.numeric)) %>% 
      as.matrix()
    
    model <- fastTS(y, x, ptrain = p.train)
    return(model)
}
```

```{r}
fastTS_stat <- function(model){
  cat('Summary Model:')
  print(summary(model))
  
  for (i in 1:10) {cat("\n")}
  cat('Results Model:')
  print(model$oos_results)
  
  for (i in 1:10) {cat("\n")}
  cat('Coefficient differnt from 0:')
  coef(model)[coef(model) != 0,]   %>% sort(decreasing = T) %>% names()
}
```

```{r}   
#model <- model_list$fits[[position of best gamma]] 
#find best gamma in summary

model_selected <- function(model_list, model, p.train = 0.8){
  
    pos <- which.min(model$loss)
    pred <- model$beta[ , pos]
    
    X <- cbind(rep(1, nrow(model_list$Xfulltrain)), model_list$Xfulltrain)
    fitted <- X %*% pred %>% matrix(ncol = 1)
    date_index <- index(model_list$y_cc_train)
    de <- coredata(model_list$y_cc_train)
    sol <- data.frame('day_ahead_price_de' = de, 
                      'fitted_day_ahead_price_de' = fitted,
                      'date' = date_index)
    sol <- sol %>% 
      mutate(difference = day_ahead_price_de - fitted_day_ahead_price_de)
    
    plot1 <- sol %>% 
      ggplot(aes(x = date))+
      scale_x_datetime(date_labels = "%Y-%m") +
      geom_line(aes(y = fitted_day_ahead_price_de, col = 'fitted_day_ahead_price_de'))+
      geom_line(aes(y = day_ahead_price_de, col = 'day_ahead_price_de')) +
      labs(title = "Prices Germany and Fitted fastTS",
       x = "Hourly data",
       y = "Price",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "fitted_day_ahead_price_de" = "blue"))
      theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    
    plot2 <- sol %>% 
      ggplot(aes(x = date))+
      scale_x_datetime(date_labels = "%Y-%m") +
      geom_line(aes(y = difference, col = 3))+
      theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    
    print(plot1)
    print(plot2)
    
    return(list(sol = sol, pred = pred, model_matrix = X))
}
```



Try to do the same  with the log-transform of the response


Construnction dataframe with covariates
```{r}
n <- nrow(df)
lag = 24
variable_forecast <- grep("forecast", names(df), value = TRUE)
df_1 <- df %>% 
  select(c(date, day_ahead_price_de,
           variable_forecast)) %>% 
  slice(1:(n-lag))


#Prices other countries
x1 <- df %>% 
  select(c(day_ahead_price_at, day_ahead_price_fr, day_ahead_price_it, 
           auction_price_ch_de, auction_price_de_ch, day_ahead_price_ch,
           allocatedCapacity_ch_de, allocatedCapacity_de_ch, ATC_ch_de, ATC_de_ch, actual_load_at, actual_load_de, actual_load_ch, actual_load_ch_missing_dummy, actual_load_fr_missing_dummy, actual_load_it_missing_dummy, actual_load_it, actual_load_fr, crossborder_actual_flow_at_ch, crossborder_actual_flow_ch_at, crossborder_actual_flow_ch_de_lu, crossborder_actual_flow_ch_fr, crossborder_actual_flow_ch_it, crossborder_actual_flow_de_lu_ch, crossborder_actual_flow_fr_ch, crossborder_actual_flow_it_ch, crossborder_actual_flow_at_ch_missing_dummy, crossborder_actual_flow_ch_at_missing_dummy, crossborder_actual_flow_ch_de_lu_missing_dummy, crossborder_actual_flow_ch_fr_missing_dummy, crossborder_actual_flow_ch_it_missing_dummy, crossborder_actual_flow_de_lu_ch_missing_dummy, crossborder_actual_flow_fr_ch_missing_dummy, crossborder_actual_flow_it_ch_missing_dummy)) %>% 
  slice((lag+1):n)

df_1 <- bind_cols(df_1, x1)

x <- df %>% select(date, dst)
x = x |> 
  mutate(
    cal_year = year(date),
    cal_month = month(date),
    cal_day_in_month = day(date),
    cal_day_in_week = wday(date, label = F),
    cal_week_in_year = week(date),
    cal_quarter = quarter(date),
    cal_hour_in_day = hour(date),
)
x <- x %>%
  select(-date)
x <- mutate_all(x, as.factor)
formula_str <- paste(" ~ -1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
                     paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)
x <- model.matrix(formula_str, data = x)

x <- x %>% 
  as.data.frame() %>% 
  slice(1:(n-lag))
df_1 <- cbind(df_1, x)  #this model does not contain many variable
```




```{r}
models <- df_1 %>% 
  filter(date > second_cut) %>% 
  mutate(day_ahead_price_de = boxcox_transform(day_ahead_price_de)) %>% 
  model_list()
```

```{r}
fastTS_stat(models)
```

```{r}
models$gamma
model <- models$fits[[1]] 
result1 <- model_selected(models, model)
```

```{r}
acf(result1$sol$difference)
pacf(result1$sol$difference)
```

```{r}
acf(abs(result1$sol$difference))   #poblems with the absolute values 
pacf(abs(result1$sol$difference)) 
```


```{r}
pos <- which.min(result1$sol$difference)
qqnorm(scale(result1$sol$difference[-pos]))
qqline(scale(result1$sol$difference[-pos]))
```



####



```{r}
models <- df_1 %>% 
  filter(date < second_cut & date > first_cut) %>% 
  mutate(day_ahead_price_de = boxcox_transform(day_ahead_price_de)) %>% 
  model_list()
```

```{r}
fastTS_stat(models)
```

```{r}
models$gamma
model <- models$fits[[1]] 
result1 <- model_selected(models, model)
```

```{r}
acf(result1$sol$difference)
pacf(result1$sol$difference)
```

```{r}
acf(abs(result1$sol$difference))   #problems with the absolute values 
pacf(abs(result1$sol$difference)) 
```


```{r}
pos <- which.min(result1$sol$difference)
qqnorm(scale(result1$sol$difference[-pos]))
qqline(scale(result1$sol$difference[-pos]))
```



### Model with added covariates
```{r}
#Prices other countries
x1 <- df %>% 
  select(-c(day_ahead_price_at, day_ahead_price_fr, day_ahead_price_it, 
           auction_price_ch_de, auction_price_de_ch, day_ahead_price_ch,
           allocatedCapacity_ch_de, allocatedCapacity_de_ch, ATC_ch_de, ATC_de_ch, actual_load_at, actual_load_de, actual_load_ch, actual_load_ch_missing_dummy, actual_load_fr_missing_dummy, actual_load_it_missing_dummy, actual_load_it, actual_load_fr, crossborder_actual_flow_at_ch, crossborder_actual_flow_ch_at, crossborder_actual_flow_ch_de_lu, crossborder_actual_flow_ch_fr, crossborder_actual_flow_ch_it, crossborder_actual_flow_de_lu_ch, crossborder_actual_flow_fr_ch, crossborder_actual_flow_it_ch, crossborder_actual_flow_at_ch_missing_dummy, crossborder_actual_flow_ch_at_missing_dummy, crossborder_actual_flow_ch_de_lu_missing_dummy, crossborder_actual_flow_ch_fr_missing_dummy, crossborder_actual_flow_ch_it_missing_dummy, crossborder_actual_flow_de_lu_ch_missing_dummy, crossborder_actual_flow_fr_ch_missing_dummy, crossborder_actual_flow_it_ch_missing_dummy,date, day_ahead_price_de,
           variable_forecast)) %>% 
  slice((lag+1):n)

df_2 <- bind_cols(df_1, x1)
```



```{r}
models <- df_2 %>% 
  filter(date > second_cut) %>% 
  mutate(day_ahead_price_de = boxcox_transform(day_ahead_price_de)) %>% 
  model_list()
```

```{r}
fastTS_stat(models)
```

```{r}
models$gamma
model <- models$fits[[1]] 
result1 <- model_selected(models, model)
```

```{r}
acf(result1$sol$difference)
pacf(result1$sol$difference)
```

```{r}
acf(abs(result1$sol$difference))   #poblems with the absolute values 
pacf(abs(result1$sol$difference)) 
```




```{r}
models <- df_2 %>% 
  filter(date < first_cut) %>% 
  mutate(day_ahead_price_de = boxcox_transform(day_ahead_price_de)) %>% 
  model_list()
```

```{r}
fastTS_stat(models)
```

```{r}
models$gamma
model <- models$fits[[1]] 
result1 <- model_selected(models, model)
```

```{r}
acf(result1$sol$difference)
pacf(result1$sol$difference)
```

```{r}
acf(abs(result1$sol$difference))   #poblems with the absolute values 
pacf(abs(result1$sol$difference)) 
```






```{r}
models <- df_2 %>% 
  filter(date > first_cut & date < second_cut) %>% 
  mutate(day_ahead_price_de = boxcox_transform(day_ahead_price_de)) %>% 
  model_list()
```

```{r}
fastTS_stat(models)
```

```{r}
models$gamma
model <- models$fits[[1]] 
result1 <- model_selected(models, model)
```

```{r}
acf(result1$sol$difference)
pacf(result1$sol$difference)
```

```{r}
acf(abs(result1$sol$difference))   #poblems with the absolute values 
pacf(abs(result1$sol$difference)) 
```
