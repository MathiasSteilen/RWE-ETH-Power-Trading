xlim = extendrange(xL, f=1/8), ylim = extendrange(yL, f=1/4))
(if(addData) points else plot)(
x.set, th, xlim = xL, ylim = yL, xlab="x", ylab=ylab, main=main,
pch = 4, cex = 0.75)
ciLine <- function(x, ci, ...)
arrows(x, ci[,1], x, ci[,2], angle=90, code=3, length=0.05, ...)
ciLine(x.set - pp/3*dx, ci, lwd=2)
ciLine(x.set + pp/3*dx, ciC, lwd=2.5, col = 2, lty = "longdash")
invisible(
cbind(x = x.set, i.alphaCorr = i.a.P, ci, ciC) )
}
plotCI_dBoot(i.alpha0 = 0.90, cover, th.B=th.B) # as in lecture notes
## other confidence levels alpha_0 :
try( plotCI_dBoot(i.alpha0 = 0.95, cover, th.B=th.B) )# --> Error  x=1   fails
try( plotCI_dBoot(i.alpha0 = 0.85, cover, th.B=th.B) )# ok {as 1-alpha --> to 0.76}
try( plotCI_dBoot(i.alpha0 = 0.88, cover, th.B=th.B) )# ok {standard ex}
try( plotCI_dBoot(i.alpha0 = 0.95, covrS, th.B=th.B) )# --> Error  x=1   fails
try( plotCI_dBoot(i.alpha0 = 0.85, covrS, th.B=th.B) )# ok {as 1-alpha --> to 0.76}
try( plotCI_dBoot(i.alpha0 = 0.88, covrS, th.B=th.B) )# ok {standard ex}
sess.info <- list(sessionInfo = sessionInfo(), Sys.info = Sys.info())
if(!interactive()) # not accidentally
save(theta, rTheta, f, plotData,
x,y, M,B,n, x.set, alphas, th.B,
cover, covrS, # <-
.CT, sess.info,
file = "doubleboot.rda")
rm(list = ls())
rm(list = ls())
diabetes <- read.table("http://stat.ethz.ch/Teaching/Datasets/diabetes2.dat",
header = TRUE)
reg <- diabetes[, c("Age", "C.Peptide")]
names(reg) <- c("x", "y")
reg <- reg[sort.list(reg$x), ]
loocv <- function(reg.data, reg.fcn)
{
## Help function to calculate leave-one-out regression values
loo.reg.value <- function(i, reg.data, reg.fcn)
return(reg.fcn(reg.data$x[-i], reg.data$y[-i], reg.data$x[i]))
## Calculate LOO regression values using the help function above
n <- nrow(reg.data)
loo.values <- sapply(1:n, loo.reg.value, reg.data, reg.fcn)
## Calculate and return MSE
mean((reg.data$y - loo.values)^2)
}
#We first plot the data, which is the same as in Figure 3.1 of the lecture notes. We guess a good
#bandwidth (h = 4), then define a regression function that can be used with loocv defined above.
par(pty="s")
plot(reg$x, reg$y, xlab = "Age", ylab = "Log-concentration")
h <- 4
reg.fcn.nw <- function(reg.x, reg.y, x)
ksmooth(reg.x, reg.y, x.points = x, kernel = "normal", bandwidth = h)$y
(cv.nw <- loocv(reg, reg.fcn.nw))
#We calculate the hat matrix ”manually” in order to calculate the degrees of freedom; this is the
#smoothing parameter used for other regression estimators:
n <- nrow(reg)
Id <- diag(n)
S.nw <- matrix(0, n, n)
for (j in 1:n)
S.nw[, j] <- reg.fcn.nw(reg$x, Id[, j], reg$x)
(df.nw <- sum(diag(S.nw)))
Id
View(Id[,2])
(Id[,2])
S.nw
View(S.nw)
S.nw %*% reg$y
S.nw %*% reg$y - reg.fcn.nw(reg$x, reg$y, reg$x)
#We also do the calculation of the CV value with the hat matrix:
y.fit.nw <- reg.fcn.nw(reg$x, reg$y, reg$x)
(cv.nw.hat <- mean(((reg$y - y.fit.nw)/(1 - diag(S.nw)))^2))
(cv.nw <- loocv(reg, reg.fcn.nw))
#Moreover, we can also simply use hatMat from the package sfsmisc:
library(sfsmisc)
#degrees of freedom
hatMat(reg$x,trace=TRUE,pred.sm=reg.fcn.nw,x=reg$x)
#Local polynomial (“lp”) regression from loess:
reg.fcn.lp <- function(reg.x, reg.y, x) {
lp.reg <- loess(reg.y ~ reg.x, enp.target = df.nw, surface = "direct")
predict(lp.reg, x)
}
(cv.lp <- loocv(reg, reg.fcn.lp))
more numerical predictors, u
#Again, we also calculate the CV value with the hat matrix constructed “manually”:
n <- nrow(reg)
more numerical predictors, u
Id <- diag(n)
more numerical predictors, u
S.lp <- matrix(0, n, n)
#Again, we also calculate the CV value with the hat matrix constructed “manually”:
n <- nrow(reg)
Id <- diag(n)
S.lp <- matrix(0, n, n)
for (j in 1:n)
S.lp[, j] <- reg.fcn.lp(reg$x, Id[, j], reg$x)
y.fit.lp <- reg.fcn.lp(reg$x, reg$y, reg$x)
(cv.lp.hat <- mean(((reg$y - y.fit.lp)/(1 - diag(S.lp)))^2))
#And once more, we also compute the CV value using hatMat:
S.lp.hatMat <- hatMat(reg$x,trace=FALSE,pred.sm=reg.fcn.lp,x=reg$x)
(cv.lp.hatMat <- mean(((reg$y - y.fit.lp)/(1 - diag(S.lp.hatMat)))^2))
est.ss <- smooth.spline(reg$x, reg$y, cv = TRUE, df = df.nw)
est.ss$cv.crit
est.ss$cv
#We then use the same smoothing parameter spar for our own calculations of the CV value:
reg.fcn.ss <- function(reg.x, reg.y, x)
{
ss.reg <- smooth.spline(reg.x, reg.y, spar = est.ss$spar)
predict(ss.reg, x)$y
}
(cv.ss <- loocv(reg, reg.fcn.ss))
est.ss$cv.crit
(cv.ss <- loocv(reg, reg.fcn.ss))
#Alternative calculation using the hat-matrix computed “manually”:
n <- nrow(reg)
Id <- diag(n)
S.ss <- matrix(0, n, n)
for (j in 1:n)
S.ss[, j] <- reg.fcn.ss(reg$x, Id[, j], reg$x)
y.fit.ss <- reg.fcn.ss(reg$x, reg$y, reg$x)
(cv.ss.hat <- mean(((reg$y - y.fit.ss)/(1 - diag(S.ss)))^2))
#And alternative calculation using hatMat:
S.ss.hatMat <- hatMat(reg$x,trace=FALSE,pred.sm=reg.fcn.ss,x=reg$x)
(cv.ss.hatMat <- mean(((reg$y - y.fit.ss)/(1 - diag(S.ss.hatMat)))^2))
#Smoothing spline regression with optimized degrees of freedom:
est.ssopt <- smooth.spline(reg$x, reg$y, cv = TRUE)
cv.ssopt <- est.ssopt$cv.crit
(cv.ssopt)
(est.ssopt$df)
Constant fit (“CF”):
#Constant fit (“CF”):
reg.fcn.cf <- function(reg.x, reg.y, x) mean(reg.y)
(cv.cf <- loocv(reg, reg.fcn.cf))
sort(c(nw=cv.nw,lp=cv.lp,ss=cv.ss,ssopt=cv.ssopt,cf=cv.cf))
plot(x, y, data = reg)
?plot
plot(data$x, data$y)
plot(reg$x, reg$y)
plot(est.ssopt$y)
plot(reg$x, reg$y)
lines(est.ssopt$x, est.ssopt$y, col = 2)
lines(est.ss$x, est.ss$y, col = 2)
plot(reg$x, reg$y)
lines(est.ssopt$x, est.ssopt$y, col = 2)
lines(est.ss$x, est.ss$y, col = 3)
lines(est.ss$x, y.fit.lp, col = 4)
lines(reg$x, y.fit.lp, col = 4)
lines(reg$x, y.fit.lp, col = 4)
plot(reg$x, reg$y)
lines(est.ssopt$x, est.ssopt$y, col = 2)
lines(est.ss$x, est.ss$y, col = 3)
lines(reg$x, y.fit.lp, col = 4)
plot(reg$x, reg$y, ylab = 'Response',  x = 'Covariates')
lines(est.ssopt$x, est.ssopt$y, col = 2)
lines(est.ss$x, est.ss$y, col = 3)
lines(reg$x, y.fit.lp, col = 4)
plot(reg$x, reg$y, ylab = 'Response',  x = 'Covariates')
plot(reg$x, reg$y, ylab = 'Response',  xlab = 'Covariates')
lines(est.ssopt$x, est.ssopt$y, col = 2)
lines(est.ss$x, est.ss$y, col = 3)
lines(reg$x, y.fit.lp, col = 4)
lines(est.ssopt$x, est.ssopt$y, col = 2, pch = 2)
lines(est.ssopt$x, est.ssopt$y, col = 2, pch = 16)
lines(est.ssopt$x, est.ssopt$y, col = 2, lty = 16)
lines(est.ssopt$x, est.ssopt$y, col = 2, lty = 4)
lines(est.ssopt$x, est.ssopt$y, col = 2, lwd = 4)
plot(reg$x, reg$y, ylab = 'Response',  xlab = 'Covariates')
lines(est.ssopt$x, est.ssopt$y, col = 2, lwd = 2)
lines(est.ss$x, est.ss$y, col = 3)
lines(reg$x, y.fit.lp, col = 4)
plot(reg$x, reg$y, ylab = 'Response',  xlab = 'Covariates')
lines(est.ssopt$x, est.ssopt$y, col = 2, lwd = 2)
lines(est.ss$x, est.ss$y, col = 3, lwd = 2)
lines(reg$x, y.fit.lp, col = 4, lwd = 2)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(ggsci)
library(scales)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Default theme for charts
theme_set(
theme_bw() +
theme(
plot.title = element_text(face = "bold", size = 14),
plot.subtitle = element_text(
face = "italic", size = 10, colour = "green50"
)
)
)
# Chunk 2
# Read data - both direction JAO
df <- read_csv("../00 Data Retrieval and Cleaning/0_df_final_imputed.csv")
# Chunk 3
df <- df %>%
mutate(date = with_tz(date, tzone = "UTC"))
df <- df %>%
mutate_at(vars(-date), as.numeric)
dummies_columns <- df %>%
select(contains("_missing_dummy")) %>%
colnames()
factor_colums <- c('dst', dummies_columns)
df <- df %>%
mutate_at(vars(factor_colums), factor)
# Chunk 4
#df = df |>
#  mutate(
#    cal_year = year(date),
#    cal_month = month(date),
#    cal_day_in_month = day(date),
#    cal_day_in_week = wday(date, label = F),
#    cal_day_in_year = yday(date),
#    cal_week_in_year = week(date),
#    cal_quarter = quarter(date),
#    cal_hour_in_day = hour(date),
#)
# Chunk 5
first_cut <- as.POSIXct("2021-06-30 23:00:00", tz = "UTC")
second_cut <- as.POSIXct("2022-12-31 23:00:00", tz = "UTC")
# Chunk 6
prices_name <- c('day_ahead_price_de',
'day_ahead_price_ch',
'auction_price_ch_de',
'auction_price_de_ch')
df_box <- df %>%
select(c('date', prices_name))
#log_transform <- function(x) {
#  log_shifted <- log(x - min(x) + 1)  # Shift all values to ensure positivity
#  return(log_shifted)
#}
boxcox_transform <- function(x, lambda) {
y = x - min(x) + 1
if (lambda == 0) {
log(y)
} else {
(y^lambda - 1) / lambda
}
}
df_box <- df_box %>%
mutate_at(vars(all_of(prices_name)), ~ boxcox_transform(., lambda = 0))
# Chunk 7
df_box %>%
filter(date < first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
labs(title = "Prices First Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 8
df_box %>%
filter(date < second_cut & date >= first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
labs(title = "Prices Second Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 9
df_box %>%
filter(date > second_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
labs(title = "Prices Third Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 10
df_box %>%
filter(date < first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
labs(title = "Prices Second Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 11
auction_price <- prices_name[3:4]
df_box[, auction_price] <- df[, auction_price]
df_box <- df_box %>%
mutate_at(vars(all_of(auction_price)), ~ boxcox_transform(., lambda = -0.001))
# Chunk 12
df_box %>%
filter(date < first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
labs(title = "Prices Second Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 13
df_box %>%
filter(date < first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
labs(title = "Prices First Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 14
df_box %>%
filter(date < second_cut & date >= first_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
labs(title = "Prices Second Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 15
df_box %>%
filter(date > second_cut) %>%
ggplot(aes(x = date)) +
geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
labs(title = "Prices Third Period",
x = "Hourly data",
y = "Price day ahead",
color = "Day ahead prices") +
scale_color_manual(values = c("day_ahead_price_de" = "green"))+
theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
# Chunk 16
date_outlier <- df_box %>%
filter(day_ahead_price_de == min(day_ahead_price_de)) %>%
pull(date)
# Chunk 17
library(fastTS)
library(xts)
# Chunk 18
substrings_to_remove <- c('_ch_de', '_de_ch', '_at', '_fr', '_ch', '_de',
'_it', '_missing_dummy', '_FR_CH', '_lu')
variable_names <- df %>% colnames() %>%
map(~str_remove_all(., paste(substrings_to_remove, collapse = "|")))  %>%
unlist() %>%
unique()
variable_names
variable_forecast <- variable_names[str_detect(variable_names, 'forecast')] %>%
str_remove('_forecast')
variable_forecast
n <- nrow(df)
lag = 24
variable_forecast <- grep("forecast", names(df), value = TRUE)
df_1 <- df %>%
select(c(date, day_ahead_price_ch, day_ahead_price_de,
auction_price_ch_de, auction_price_de_ch, variable_forecast)) %>%
slice(1:(n-lag))
#prices other countries
x1 <- df %>%
select(c(day_ahead_price_at, day_ahead_price_fr, day_ahead_price_it)) %>%
slice((lag+1):n)
df_1 <- cbind(df_1, x1)
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
mutate_if(~ !is.POSIXct(.), as.factor)
interaction(x, drop = TRUE)
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
mutate_if(~ !is.POSIXct(.), as.factor)
interaction_terms <- interaction(x[, setdiff(names(x), 'dst')], x[['dst']], drop = TRUE)
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
select(-date) %>%
mutate_all(as.factor())
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
select(-date) %>%
mutate_all(as.factor(.))
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
select(-date)
x <- mutate_all(x, as.factor())
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_day_in_year = yday(date),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
select(-date)
x <- mutate_all(x, as.factor)
x %>% str()
interaction_terms <- interaction(x[, setdiff(names(x), 'dst')], x[['dst']], drop = TRUE)
interaction_terms
interaction_terms
interaction_terms <- interaction(x[, -which(names(x) == "dst")], x$dst, drop = TRUE)
interaction_terms
formula_str <- paste("dst ~ ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str
formula_str <- paste("dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str
x <- model.matrix(~ -1 formula_str, data = x)
formula_str <- paste("-1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)
x <- model.matrix(~ formula_str, data = x)
x %>% str()
x <- df %>% select(date, dst)
x = x |>
mutate(
cal_year = year(date),
cal_month = month(date),
cal_day_in_month = day(date),
cal_day_in_week = wday(date, label = F),
cal_week_in_year = week(date),
cal_quarter = quarter(date),
cal_hour_in_day = hour(date),
)
x <- x %>%
select(-date)
x <- mutate_all(x, as.factor)
interaction_terms <- interaction(x[, -which(names(x) == "dst")], x$dst, drop = TRUE)
formula_str <- paste("-1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)
formula_str
formula_str <- as.formula(formula_str)
x <- model.matrix(~ formula_str, data = x)
formula_str <- paste("-1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)
formula_obj <- formula(formula_str)
formula_str <- paste(" ~ -1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_obj <- formula(formula_str)
formula_str <- paste(" ~ -1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)
x <- model.matrix(~ formula_str, data = x)
x <- model.matrix(formula_str, data = x)
View(x)
