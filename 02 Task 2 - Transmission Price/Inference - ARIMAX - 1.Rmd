---
title: "ARIMAX"
author: "Federico Deotto"
date: "2024-03-12"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(ggsci)
library(scales)



setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Default theme for charts
theme_set(
  theme_bw() +
    theme(  
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(
        face = "italic", size = 10, colour = "green50"
      )
    )
)

```

## The Goal

Select variables based on availability (NA) and variance, ensuring conversion to the appropriate type (e.g., converting integers into numeric data).

```{r}
# Read data - both direction JAO
df <- read_csv("../00 Data Retrieval and Cleaning/0_df_final_imputed.csv")

df$date %>% str()
```

Convert dummies for missing values and variable dst into factor, and ensure that all numeric colums are encoded as such.

```{r}
df <- df %>%
  mutate_at(vars(-date), as.numeric)

dummies_columns <- df %>%
  select(contains("_missing_dummy")) %>% 
  colnames()

factor_colums <- c('dst', dummies_columns)

df <- df %>%
  mutate_at(vars(factor_colums), factor)
```

Added by M: create calendar features

- Careful: "date" is in UTC, hour in day in our time zone will change, need to include interaction with the "dst" variable

```{r}
df = df |> 
  mutate(
    cal_year = year(date),
    cal_month = month(date),
    cal_day_in_month = day(date),
    cal_day_in_week = wday(date, label = F),
    cal_day_in_year = yday(date),
    cal_week_in_year = week(date),
    cal_quarter = quarter(date),
    cal_hour_in_day = hour(date),
)
```


# Cutting of time series 

The timestamps are selected arbitrarily. The guiding idea behind the choice was to roughly recover some stationarity conditions in the log-transformed price.
```{r}
first_cut <- as.POSIXct("2021-06-30 23:00:00", tz = "UTC")
second_cut <- as.POSIXct("2022-12-31 23:00:00", tz = "UTC")
```

Create a data.frame that contains exclusively the log_transfo of the four prices and their timestamp (date).
```{r}
prices_name <- c('day_ahead_price_de', 
                 'day_ahead_price_ch',
                 'auction_price_ch_de',
                 'auction_price_de_ch')
df_box <- df %>% 
  select(c('date', prices_name))

#log_transform <- function(x) {
#  log_shifted <- log(x - min(x) + 1)  # Shift all values to ensure positivity
#  return(log_shifted)
#}

boxcox_transform <- function(x, lambda) {
  y = x - min(x) + 1
  if (lambda == 0) {
    log(y)
  } else {
    (y^lambda - 1) / lambda
  }
}


df_box <- df_box %>%
  mutate_at(vars(all_of(prices_name)), ~ boxcox_transform(., lambda = 0))
```


```{r}
# Make the chart
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
# Make the chart
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
# Make the chart
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


We can see that the log_transfo is not good with the auction_prices. Try another boxCox transfo in order to take care of skewness. The interpretability of the final modell will be compromise, since the log transfo guarantees an interpretation of the coef in terms of percentage change.

```{r}
# Make the chart
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```

```{r}
auction_price <- prices_name[3:4]
df_box[, auction_price] <- df[, auction_price]

df_box <- df_box %>%
  mutate_at(vars(all_of(auction_price)), ~ boxcox_transform(., lambda = -0.001))
```



```{r}
# Make the chart
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


# PRICE ELECTRICITY GERMANY

In this section we focus in the analysis of the german elcetricity price.

```{r}
# Make the chart
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
# Make the chart
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
# Make the chart
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```



```{r}
date_outlier <- df_box %>%
  filter(day_ahead_price_de == min(day_ahead_price_de)) %>% 
  pull(date)
```


```{r}
library(fastTS)
library(xts)
```

```{r}
substrings_to_remove <- c('_ch_de', '_de_ch', '_at', '_fr', '_ch', '_de',
                          '_it', '_missing_dummy', '_FR_CH', '_lu')

variable_names <- df %>% colnames() %>% 
  map(~str_remove_all(., paste(substrings_to_remove, collapse = "|")))  %>%
  unlist() %>% 
  unique()

variable_names

variable_forecast <- variable_names[str_detect(variable_names, 'forecast')] %>%
  str_remove('_forecast')
variable_forecast
```

Is there a way to select variables before training? First, let's consider how the day-ahead price is determined. The price for tomorrow (t+24:48) is established using all available information as of today morning (t). 
So, if not justified by further reasoning, it doesn't make sense to use the actual quantity of electricity from water reservoirs at (t+24) to model the electricity price at (t+24) (prediction context). While there are cases where the electricity production for the next day can be predicted quite accurately, it's not necessarily true for all variables we're considering. Therefore, the preferred approach is to use forecasts, which may not perfectly align with those used by traders during auctions but are the closest approximation.

In instances where forecasts are unavailable, we'll resort to using actual production data at (t+24), which can serve as a proxy for a forecast (assuming our company possesses highly accurate internal predictions). However, this approach is subject to debate (prediction context).

The previous arguments were all based on the assumption of a model that needs to be cautious about potential data leakage, as we aim for a model that precisely replicates how prices are formed and can be deployed within a company. Additionally, there's a more descriptive approach that involves utilizing variables observed at time t+24. The rationale for doing this is to discover possible insights.

We'll adapt three models:

The first model incorporates additional information and is lagged by 24 hours, effectively simulating an internal forecast. In this model, we must avoid using prices from other countries at time t+24 for the JAO prediction, as this would constitute a significant information leak. However, for the Switzerland price, we can use the JAO results; analogously for Germany, Austria, France, and Italy, we can use the prices of Switzerland and JAO. The second model includes only the forecasted variables (solar, wind onshore, capacity). The third takes into account all variables.


```{r}
# Make the chart
a_cut <- as.POSIXct("2021-08-30 23:00:00", tz = "UTC")
b_cut <- as.POSIXct("2021-10-30 23:00:00", tz = "UTC")
df %>% 
  filter(date < b_cut & date > a_cut ) %>% 
  ggplot(aes(x = date)) +
    geom_line(aes(y = ATC_de_ch, color = "ATC_de_ch"), lwd = 1) +
  geom_line(aes(y = ATC_ch_de, color = "ATC_ch_de"), lwd = 1) +
  scale_x_datetime(date_breaks = "11 hour", date_labels = "%H") +
  labs(title = "ATC",
       x = "Hourly data",
       y = "ATC",
       color = "ATC") +
  scale_color_manual(values = c("ATC_de_ch" = "cyan", "ATC_ch_de" = "grey"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```






#SHINY TWO TIMESERIES

```{r}
library(shiny)

numeric_columns <- colnames(select_if(df, is.numeric))

# Define UI for the application
ui <- fluidPage(
  
  # Application title
  titlePanel("Interactive Time Series Plot"),
  
  # Sidebar layout
  sidebarLayout(
    sidebarPanel(
      # Select input for choosing time series
      selectInput("time_series1", "Select Time Series:",
                  choices = numeric_columns),
      selectInput("time_series2", "Select Time Series:",
                  choices = numeric_columns),
      dateRangeInput("date_range", "Select Date Range:",
                     start = min(df$date), end = max(df$date),
                     min = min(df$date), max = max(df$date)),
      tags$style(".sidebar {width: 100px; height: 600px; overflow-y: auto;}")

    ),
    
    # Main panel with plot
    mainPanel(
      plotOutput("time_series_plot", height = "700px", width = "100%")
    )
  )
)

# Define server logic
server <- function(input, output) {
  

  # Reactive expression for filtered data based on selected time series and time window
  filtered_data <- reactive({
    df %>%
      filter(date >= input$date_range[1] & date <= input$date_range[2]) %>% 
      select(date, !!input$time_series1, !!input$time_series2)
  })
  
  output$time_series_plot <- renderPlot({
    ggplot(filtered_data(), aes(x = date)) +
      geom_line(aes(y = !!sym(input$time_series1),color = "time_series1")) +
      geom_line(aes(y = !!sym(input$time_series2),color = "time_series2")) +
      labs(title = "Time Series Plot", x = "Date Time", y = "Value")+
      scale_color_manual(values = c("time_series1" = "cyan","time_series2" = "grey"))+
      theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")})
  
}


# Run the application
shinyApp(ui = ui, server = server)
```

