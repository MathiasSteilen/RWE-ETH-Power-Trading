---
title: "ARIMAX"
author: "Federico Deotto"
date: "2024-03-12"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(ggsci)
library(scales)



setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Default theme for charts
theme_set(
  theme_bw() +
    theme(  
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(
        face = "italic", size = 10, colour = "green50"
      )
    )
)

```

## The Goal

Adapt an ARIMAX model.


```{r}
# Read data - both direction JAO
df <- read_csv("../00 Data Retrieval and Cleaning/0_df_final_imputed.csv")
```

Convert dummies for missing values and variable dst into factor, and ensure that all numeric colums are encoded as such.

```{r}
df <- df %>% 
  mutate(date = with_tz(date, tzone = "UTC"))

df <- df %>%
  mutate_at(vars(-date), as.numeric)

dummies_columns <- df %>%
  select(contains("_missing_dummy")) %>% 
  colnames()

factor_colums <- c('dst', dummies_columns)

df <- df %>%
  mutate_at(vars(factor_colums), factor)
```

Added by M: create calendar features

- Careful: "date" is in UTC, hour in day in our time zone will change, need to include interaction with the "dst" variable

```{r}
#df = df |> 
#  mutate(
#    cal_year = year(date),
#    cal_month = month(date),
#    cal_day_in_month = day(date),
#    cal_day_in_week = wday(date, label = F),
#    cal_day_in_year = yday(date),
#    cal_week_in_year = week(date),
#    cal_quarter = quarter(date),
#    cal_hour_in_day = hour(date),
#)
```


# Cutting of time series 

The timestamps are selected arbitrarily. The guiding idea behind the choice was to roughly recover some stationarity conditions in the log-transformed price.
```{r}
first_cut <- as.POSIXct("2021-06-30 23:00:00", tz = "UTC")
second_cut <- as.POSIXct("2022-12-31 23:00:00", tz = "UTC")
```

Create a data.frame that contains exclusively the box_transformation of the four prices and their timestamp (date).
```{r}
prices_name <- c('day_ahead_price_de', 
                 'day_ahead_price_ch',
                 'auction_price_ch_de',
                 'auction_price_de_ch')
df_box <- df %>% 
  select(c('date', prices_name))

#log_transform <- function(x) {
#  log_shifted <- log(x - min(x) + 1)  # Shift all values to ensure positivity
#  return(log_shifted)
#}

boxcox_transform <- function(x, lambda) {
  y = x - min(x) + 1
  if (lambda == 0) {
    log(y)
  } else {
    (y^lambda - 1) / lambda
  }
}


df_box <- df_box %>%
  mutate_at(vars(all_of(prices_name)), ~ boxcox_transform(., lambda = 0))
```


```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  geom_line(aes(y = day_ahead_price_ch, color = "day_ahead_price_ch")) +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green", "day_ahead_price_ch" = "red"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


We can see that the log_transformation is not good with the auction_prices. Try another boxCox transformation in order to take care of skewness. The interpretability of the final modell will be compromise, since the log transformation guarantees an interpretation of the coeficient in terms of percentage change.

```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```

```{r}
auction_price <- prices_name[3:4]
df_box[, auction_price] <- df[, auction_price]

df_box <- df_box %>%
  mutate_at(vars(all_of(auction_price)), ~ boxcox_transform(., lambda = -0.001))
```



```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = auction_price_ch_de, color = "auction_price_ch_de")) +
  geom_line(aes(y = auction_price_de_ch, color = "auction_price_de_ch")) +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("auction_price_de_ch" = "orange", "auction_price_ch_de" = "blue" ))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


# PRICE ELECTRICITY GERMANY

In this section we focus in the analysis of the german elcetricity price.

```{r}
df_box %>% 
  filter(date < first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices First Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date < second_cut & date >= first_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Second Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
df_box %>% 
  filter(date > second_cut) %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = day_ahead_price_de, color = "day_ahead_price_de")) +
  scale_x_datetime(date_labels = "%Y-%m", date_breaks="4 months") +
  labs(title = "Prices Third Period",
       x = "Hourly data",
       y = "Price day ahead",
       color = "Day ahead prices") +
  scale_color_manual(values = c("day_ahead_price_de" = "green"))+
  theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
```


```{r}
date_outlier <- df_box %>%
  filter(day_ahead_price_de == min(day_ahead_price_de)) %>% 
  pull(date)
```


```{r}
library(fastTS)
library(xts)
```

```{r}
substrings_to_remove <- c('_ch_de', '_de_ch', '_at', '_fr', '_ch', '_de',
                          '_it', '_missing_dummy', '_FR_CH', '_lu')

variable_names <- df %>% colnames() %>% 
  map(~str_remove_all(., paste(substrings_to_remove, collapse = "|")))  %>%
  unlist() %>% 
  unique()

variable_names

variable_forecast <- variable_names[str_detect(variable_names, 'forecast')] %>%
  str_remove('_forecast')
variable_forecast
```

Is there a way to select variables before training? First, let's consider how the day-ahead price is determined. The price for tomorrow (t+24:48) is established using all available information as of today morning (t). 
So, if not justified by further reasoning, it doesn't make sense to use the actual quantity of electricity from water reservoirs at (t+24) to model the electricity price at (t+24) (prediction context). While there are cases where the electricity production for the next day can be predicted quite accurately, it's not necessarily true for all variables we're considering. Therefore, the preferred approach is to use forecasts, which may not perfectly align with those used by traders during auctions but are the closest approximation.

In instances where forecasts are unavailable, we'll resort to using actual production data at (t+24), which can serve as a proxy for a forecast (assuming our company possesses highly accurate internal predictions). However, this approach is subject to debate (prediction context).

The previous arguments were all based on the assumption of a model that needs to be cautious about potential data leakage, as we aim for a model that precisely replicates how prices are formed and can be deployed within a company. Additionally, there's a more descriptive approach that involves utilizing variables observed at time t+24. The rationale for doing this is to discover possible insights.

We'll adapt three models:

The first model incorporates additional information and is lagged by 24 hours, effectively simulating an internal forecast. In this model, we must avoid using prices from other countries at time t+24 for the JAO prediction, as this would constitute a significant information leak. However, for the Switzerland price, we can use the JAO results; analogously for Germany, Austria, France, and Italy, we can use the prices of Switzerland and JAO. The second model includes only the forecasted variables (solar, wind onshore, capacity).In these two models is also necessary to set the lag as covariates greater than 23.  The third takes into account all variables.



#SHINY TWO TIME SERIES AND SCALED

```{r}
# Define UI for the application
ui <- fluidPage(
  
  # Application title
  titlePanel("Interactive Time Series Plot"),
  
  # Sidebar layout
  sidebarLayout(
    sidebarPanel(
      # Select input for choosing time series
      selectInput("time_series1", "Select Time Series 1:",
                  choices = colnames(select_if(df, is.numeric))),
      selectInput("time_series2", "Select Time Series 2:",
                  choices = colnames(select_if(df, is.numeric))),
      dateRangeInput("date_range", "Select Date Range:",
                     start = min(df$date), end = max(df$date),
                     min = min(df$date), max = max(df$date)),
      radioButtons("plot_type", "Plot Type:",
                   choices = c("Original", "Scaled and Centered"),
                   selected = "Original"),
      tags$style(".sidebar {width: 100px; height: 600px; overflow-y: auto;}")
    ),
    
    # Main panel with plot
    mainPanel(
      plotOutput("time_series_plot", height = "700px", width = "100%")
    )
  )
)

# Define server logic
server <- function(input, output) {
  
  # Reactive expression for filtered data based on selected time series and time window
  filtered_data <- reactive({
    df %>%
      filter(date >= input$date_range[1] & date <= input$date_range[2]) %>% 
      select(date, !!input$time_series1, !!input$time_series2)
  })
  
  # Reactive expression for scaled and centered data
  scaled_centered_data <- reactive({
    data <- filtered_data()
    if (input$plot_type == "Scaled and Centered") {
      for (col in c(input$time_series1, input$time_series2)) {
        data[[col]] <- scale(data[[col]], center = TRUE, scale = TRUE)
      }
    }
    return(data)
  })
  
  output$time_series_plot <- renderPlot({
    if (input$plot_type == "Original") {
      ggplot(filtered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Time Series Plot", x = "Date Time", y = "Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    } else {
      ggplot(scaled_centered_data(), aes(x = date)) +
        geom_line(aes(y = !!sym(input$time_series1), color = "time_series1")) +
        geom_line(aes(y = !!sym(input$time_series2), color = "time_series2")) +
        labs(title = "Scaled and Centered Time Series Plot", x = "Date Time", y = "Scaled and Centered Value") +
        scale_color_manual(values = c("time_series1" = "cyan", "time_series2" = "grey")) +
        theme(plot.margin = margin(10, 10, 10, 10), legend.position = "bottom")
    }
  })
  
}

# Run the application
shinyApp(ui = ui, server = server)


```



# SPARSE LASSO



In the following chunk we create the matrfix of the covariates based on the criteria explained previously. The matrix for the model with all sync variables is not hear since Idk how to construct it.
```{r}
n <- nrow(df)
lag = 24
variable_forecast <- grep("forecast", names(df), value = TRUE)
df_1 <- df %>% 
  select(c(date, day_ahead_price_ch, day_ahead_price_de,
           auction_price_ch_de, auction_price_de_ch, variable_forecast)) %>% 
  slice(1:(n-lag))

#prices other countries
x1 <- df %>% 
  select(c(day_ahead_price_at, day_ahead_price_fr, day_ahead_price_it)) %>% 
  slice((lag+1):n)

df_1 <- cbind(df_1, x1)

#name_temp <- colnames(df_1)
#x <- df %>% 
#  select(-name_temp) %>% 
#  slice(1:(n-lag))
#
#df_2 <- cbind(df_1, x)
#
#x <- df %>% 
#  select(-name_temp) %>% 
#  slice((lag+1):n)
#
#df_3 <- cbind(df_1, x)
```

```{r}
x <- df %>% select(date, dst)

x = x |> 
  mutate(
    cal_year = year(date),
    cal_month = month(date),
    cal_day_in_month = day(date),
    cal_day_in_week = wday(date, label = F),
    cal_week_in_year = week(date),
    cal_quarter = quarter(date),
    cal_hour_in_day = hour(date),
)

x <- x %>%
  select(-date)

x <- mutate_all(x, as.factor)


formula_str <- paste(" ~ -1 + dst + ", paste(names(x)[-which(names(x) == "dst")], collapse = " + "), " + ",
                     paste(names(x)[-which(names(x) == "dst")], ":", "dst", sep = "", collapse = " + "), sep = "")
formula_str <- formula(formula_str)

x <- model.matrix(formula_str, data = x)
```




```{r}
library(fastTS)
library(xts)

df3 <- df_3 %>% 
  filter(date > second_cut)
  

y <- xts(df3$day_ahead_price_de,
       order.by = df3$date)

x <- df3 %>% 
  select(-c(date, day_ahead_price_de))

x <- x %>%
  mutate(across(everything(), as.numeric)) %>% 
  as.matrix()

fit1 <- fastTS(y, x, ptrain = 0.8)
#x1 <- scale(x) %>% as.data.frame() %>%   select_if(~ !any(is.na(.)))
#fit2 <- fastTS(y, scale(x1))

summary(fit1)
#summary(fit2)
```


Don't really got it how the scaling works. From CRAN seems it scale but if I first scale obtain different results.

```{r}
#fit1$oos_results
#fit2$oos_results
#
#
#coef(fit1)[coef(fit1) != 0] %>% sort()
#cat("\n")
#cat("\n")
#cat("\n")
#coef(fit2)[coef(fit2) != 0] %>% sort()
#
#
#
#
#ll <- coef(fit2)[coef(fit2) != 0] %>% sort()-coef(fit1)[coef(fit1) != 0] %>% #sort()
#ll %*% rep(1, 240) 
```

```{r}
coef(fit1)[coef(fit1) != 0,]   %>% sort(decreasing = T) %>% names()

#lol <- as.matrix(coef(fit1) %>% sort(decreasing = T))
#
#lol <- coef(fit2)[coef(fit2) != 0,] %>% sort(decreasing = F) %>% names()
#lol[!grepl("lag", lol)]
```

```{r}
fit1$fits
lol <- fit1$fits 
lol <- lol[[1]]

lol$linear.predictors

f1 <- fit1$fits[[1]]
f2 <- fit1$fits[[2]]


f1$lambda %>% length()
f1$gamma
pos <- which.min(f1$loss)
f1$beta[ , pos]


library(ncvreg)
```






